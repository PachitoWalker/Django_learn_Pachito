Ну что. Прошлый файл справки на 300 строк изучен? Отлично. Но теперь, вместо 7 часов у меня ролик на 11 часов + 3.5 часа + 1.5 часа + 0.5 часа, так что строк здесь будет... Ну раза в 
2 больше. Удачи мне! 
P.S Это по Jango 


В папке templates-for-Django... находится верстка сайта. Делал её не я, а автор видика.

Первым делом, надо установить расширение для Django От baptise darthenay (думаю тут проблем не возникнет)



                                                                    Подготовка



1. Создание виртуального окружения (это для windows, для linux/mac команды другие)
    
    
    1. В терминале прописываю: python -m venv venv 

    2. Там же активирую окружение: venv\Sctipts\activate 
        P.S если вылетает такая ошибка:
            venv\Scripts\activate : Невозможно загрузить файл C:\Users\User\lesson3\venv\Scripts\Activate.ps1, так как выполнение сценариев 
            отключено в этой системе. Для получения дополнительных сведений см. about_Execution_Policies по адресу https:/go.microsoft.com/fwlink/?LinkID=135170.
        То:
            Открыть powershell от администратора, вписать:
            Set-ExecutionPolicy RemoteSigned
            Ответить A 
    


2. Установка django:

    pip install Django (в терминале)



3. Создание проекта:

    django-admin startproject NameOfProject (в терминал)



4. Перейти в папку проекта:

    cd ./NameOfProject



5. Что бы сделать виртуальное окружение постоянно активным:

    1. Просто откроем файл manage.py в папке проекта
    2. В vs code снизу написан интерпретатор - python 3.12. Нажимаю на него 
    3. Выбираю введите путь к интерпретатору
    4. Нажимаю найти
    5. Выбираю venv - Scripts - python.exe



6. Запуск локального сервера:

    python manage.py runserver (в терминал)
    После этого появится "ошибка" you have 18 unapplied migrations... Сейчас на нее внимание не обращаю, что бы открыть сервер - ctrl и клик на адрес 



7. Следущим этапом надо автоматизировать запуск сервера по комбинации клавиш:

    1. В vs code выбрать в левом баре Run and Debag, и нажимаю launch.json file, python debugger, django.



КАКИЕ ФАЙЛЫ СОДЕРЖАТСЯ В NameOfProject:
    __init__.py - сообщает Python, что все файлы в папке взаимосвязаны
    asgii, wsgi - отвечают за то, ассинхронный и синхронный способ общения django с сервером. Для онлайн-чатов - asgi, для обычного интернет-магазина - wsgi 
    urls.py - ссылки в приложении. По умолчанию есть маршрут admin - то есть если в браузере вписать хост/admin, то откроется вход в панель админа от джанго (встроенный)
    settings.py - все настройки проекта:

        ПЕРЕМЕННЫЕ И ЗА ЧТО ОНИ ОТВЕЧАЮТ (В SETTINGS.py):

            base_dir - переменная с путем до каталога проекта
            secret_key - секретный ключ, что позволяет корректно работать. Каждый раз генирируется
            debug - включена/выключена отладочная информация (при разработке - True, при деплойте - True)
            Installed_apps - установленные приложения в проекте (логические блоки в web приложении)
            root_urlconf - все url адреса приложения 
            templates - шаблонизатор с наполнением приложения 
            Databases - подключение баз данных 
            static_url - адрес для получения статик файлов 



8. Создание приложения:

    python manage.py startapp NameOfApp (в терминал)



9. Регистрация приложения в проекте:
    
    В файл settings.py В insalled_apps дописываю имя приложения





КАКИЕ ФАЙЛЫ СОДЕРЖИТ КАЖДОЕ СОЗДАННОЕ ПРИЛОЖЕНИЕ:
    Папка migrations - там применяются файлы миграции, то есть файлы, которые будут прописывают, какие таблицы будут создаваться в БД по надобности
    __init__ - То же, что и раньше 
    admin - файл для регистрации таблиц в админ панели 
    apps - настройки и конфигурация приложения 
    models - Описание, какие таблицы будут храниться и для чего
    test - написание автоматизированных тестов проверки кода на работоспособность 
    views - функции/классы, отрабатывающие запросы пользователя. Запрашивает данные из бд и записывает в Models.py, обрабатывается, и передается в templates, затем возвращает ответ в виде страницы

    

Архитектура MTV (Model Template View): 
    Как происходит взаимодействие при запросе страницы:
        Пользователь запрашивает страницу main (проще говоря, переходит по ссылке на эту страницу). Тогда django, отбросив домен, просматривает, есть ли в urls.py такая страница main. 
        Если он находит там необходимый маршрут, то вызывается функция, или класс, описанные во views.py этого приложения, и эта функция исполняет ответ:
            Запрашивает данные из базы данных и записывает этот код в models.py, информация возвращается в функцию. Там она обрабатывается. Затем эта информация передается в templates - пустой 
            html шаблон заполняется обработанной информацией и возвращается в views. Там спец. функция - контроллер, или представление, возвращает response (ответ) - готовую страницу пользователю



                                                                                    Основная часть



ПРИЛОЖЕНИЕ MAIN:


    1. Конечно же, сразу после создания регистрирую его в settings проекта, в insalled_apps.

    2. Создаю контроллер, который будет обрабатывать запросы в views.py (функция index). Так же небходимо импортировать HttpResponse:

        from django.http import HttpResponse



    3. Закрепляю контроллер за url адресом:
        
        1. В файле urls.py есть коллекция - urlpatterns. Добавляю в нее маршрут: у нас есть доменное имя - https://name_of_host . Я добавляю в нее path('a',func) где:
            
            a - это страница: то, что будет идти после домена. Например:

                Есть главная страница - https://name_of_host/ . Значит для нее a это ничего. path('', func)
                А для страницы account - https://name_of_host/account. Значит для страницы аккаунта a = account    =>    path('account', func, name)
    


            func - это ссылка на контроллер для этой страницы:

                Для главной страницы контроллер - index, он лежит в views папки main. Значит я импортирую файл views сюда, в urls.py: 
                
                    from main import views, 
                    
                    

                Записываю ссылку в коллекцию: 
                    
                    ('',views.index)



                Для account контроллер - auth, значит:
                    
                    from user import views
                    path('account', views.account)
    


            name = 'name' - имя, необходимое для последующего использования в шаблонах (например если ссылка на страницу изменится, а обращались мы всегда по имени, имя во всем коде не придется менять)
    


    4. В директории приложения создаем папку для html - templates. Т.к приложений может быть много, а файлы html могут иметь одно название, то внутри целесообразно создать еще одну - с названием приложения
        То есть в директории main создаю папку templates, а в папке templates создаю папку main. В эту папку перекидываю все html файлы для этого приложения 

    5. В views.py для отображения страницы "return HttpResponse('home page')" меняем на "return render(request, 'path_to_html')" (без ""). Из названия понятно, что ф-я render отображает html страницу. 
    Первым аргументом всегда передаю request, вторым - путь до html файла (в данном случае получится return render(request, 'main/index.html'))
        
        Так же можно передать в render context - это словарь, который я сам пишу внутри контроллера. Например:
            
            context = {
                'title': 'Home',
                'content': 'Главная страница магазина - HOME'
            }
            return render(requet, 'main/index.html', context)



        Но при загрузки страницы этих данных я не увижу. Что бы их получить:
            
            в index.html, в теге title я пишу {{ title }}
            в теге body пишу {{ content }}



        При обновлении я их увижу. Но для качественного примера, нужно добавить в context еще пару значений:
       
        context = {
            'title': 'Home', 
            'content': 'Главная страница магазина - HOME',
            'list': ['first', 'second'],
            'dict': {'first':1},
            'bool': True
        }

       
       
        Тогда, если я в body напишу:
       
            <p> {{ content }} </p>
            <p> {{ list }} </p>
            <p> {{ dict }} </p>
            <p> {{ bool }} </p>

            {{ text }} называется ПЛЕЙСХОЛДЕР



        То получу такую страницу:

            Главная страница магазина - HOME 
            ['first', 'second']
            {'first':1}
            True 



        Конечно мне нужны именно значения, а не сами списки, словари и сырые данные. НО. Что бы их получить, например, из словаря, я пишу не dict.get(first), а dict.first. Не list[0], а list.0 :
            
            <p> {{ content }} </p>
            <p> {{ list.0 }} </p>
            <p> {{ dict.first }} </p>
            <p> {{ bool }} </p>



        Тогда я получаю правильный вывод:
            
            Главная страница магазина - HOME
            first
            1
            True



    ДРУГИЕ ШАБЛОННЫЕ ТЕГИ:

        Шаблонный тег if: 

            {% if a>b %}
                <p> a больше b </p>
            {% endif %}



                То есть, например, в context (в views.py ) у меня добавлено 'is_authetificated':True, то при
                    
                    {% if is_authetificated %}
                        <p> Вы авторизованы !!! </p>
                    {% endif %}
                


                Я получу такой вывод на странице:

                    Вы авторизоваваны !!!



        Шаблонный тег for:

            {% for a in b %}
                тег
                    вложенный тег 
                        вложенный тег с a 
                        закрывающий тег 
                    закрывающий тег 
                закрывающий тег 
            {% endfor %}

            Это такой же, как и в python тег for, действующий точно так же.



    6. Заливаю нынешние изменения в репозиторий. (О том, как это делать, говорилось в lesson3)

                НЕОБЯЗАТЕЛЬНАЯ ИНФА, ПРОСТО НА ЗАМЕТКУ

                1. Итак. Дальше я создал новую папку, и открыл ее в vs code. В эту папку с помощью git clone я склонировал код из проекта автора (ссылка: https://github.com/PythonHubStudio/Django-4-course-Home.git)

                2. Что бы увидеть список изменений и коммитов в проекте воспользуюсь командой git log --graph --all --oneline. Если мне нужен старый код, то вбиваю git checkout хэш, где хэш - это то что желтое
                    в консоли


==============================Итак, я скопировал папку с проектом и открыл ее в vs code. Сейчас я работаю в ней. Не забудь проверить, что виртуальная среда активна. Если нет - активируй.==========================



    7. Переношу верстку в приложение. 

        1. Заменяю временный index.html на конечный. Запускаю сервер, открываю страницу, и вижу: html загрузился.



        2. ПОДКЛЮЧЕНИЕ СТАТИКОВ:

            1. Создаю папку static внутри приложения, и закидываю внутрь все статик-файлы из верстки (папка deps). Ничего не меняется. Значит, захожу в index.html и смотрю, как подключены static файлы:
                Видно, что static files имеют путь deps/css/my_css.css . Такое расположение работает только в том случае, если папка deps лежит рядом с index.html. И просто поменять путь не выйдет. Для 
                подключения static файлов:
            
                    1. В самом верху index.html прописываю {% load static %} - то есть загрузить static файлы по пути "Имя приложения, в котором Index.html/static".
            
                    2. Теперь все ссылки для подключения статики меняем (вообще все, где есть обращение к папке static (или deps)):

                        Было:
                            <link ... href = "deps/css/my_css.css">
                    
                    
                    
                        Стало:
                            <link ... href = "{% static "deps/css/my_css.css" %}">



            2. У меня один css на весь проект, значит и целесообразно расположить папку static в корне проекта:
            
                1. В файле settings прописываю путь до папки static (под static_urls):
                    STATICFILES_DIRS = (
                        BASE_DIR / 'static',
                    )



                2. Создаю в корне папку static, переношу в нее deps из static внутри приложения. Первоначально созданная папка static мне не нужна, и я ее удаляю (тем более что она теперь пустая)

                    Таким образом, STATICFILES_DIRS перекроет static_url. STATICFILES_DIRS ищет папку static в корне, а static_url - в приложении.




    8. Помнишь одно из основ программирования: один и тот же участок кода не должен повторяться несколько раз. Это относится и к html, а ведь в моих html документах уйма одинакового кода. Исправляю: 
     Создам базовый html документ, из которого будут переноситься одинаковые участки кода в разные документы:

        1. Создаю в templates файл base.html, и копирую в него весь код из index.html.

        2. В base.html оставляю только те части кода, которые часто повторяются: навигационную панель, корзину и тд. Уникальным придумываю имя и заменяю на <% block name_of_block %><% endblock %>

        3. В файле index.html (и во всех остальных html документах) наоборот, оставляю только уникальные для них части кода. Эти уникальные части я оборачиваю в block с придуманным для них именем:

            <% block name_of_block %>
                УНИКАЛЬНЫЙ код
            <% endblock %>



        4. Вверху файла index.html (и всех файлов, для которых я провел эту процедуру) прописываю: 
        
            {% extends path_to_basehtml %} (в моем случае это: {% extends main/base.html %})



        5. Если объяснить простым языком, то в веб приложении теперь всегда отображается base.html . И страница "о нас", и страница "каталог". Ведь они имеет очень много одинаковых элементов, например navbar, 
        который есть на каждой странице в моем проекте. Но в зависимости от того, какой html документ должен отображаться, base.html как бы 'дополняется' от него: допустим, есть в файле catalog уникальный блок
        с карточкой товара: тогда он обернут в block с именем... card-product (это пример, который не имеет ничего общего с данным проектом). Тогда, в файл base.html, там где я указал этот блок, вставляется код,
        обернутый в catalog.html. Надеюсь, стало немного яснее, а не еще запутаннее.



    9. Теперь мне нужно, что бы на основной страницы был такой текст: "Магазин мебели HOME", и называлась эта вкладка в браузере - "Home - Главная". Что вы это сделать:
    
        1. Изменю контроллер на такой:

            context = { 
                'title': 'Home - Главная'
                'content': 'Магазин мебели HOME'
            }



        2. В index.html и base.html делаю так, что бы content и title подгружался из контроллера:

            В index.html:  
                
                <h1 ...><strong> {{ content }} </strong></h1>
                
                
            
            В base.html:
                <title> {{ title }} </title>



    10. ТЕПЕРЬ ДЕЛАЮ СТРАНИЧКУ about. Создаю файл about.html в templates/main и копирую в него все из index.html

    11. Переделываю контроллер для about подобно index. (указывать не буду, тк там ctrl+c ctrl+v с заменой очевидных значений: голову включи) )
 
    12. В about.html немного изменяю блок content, что я делал итак ясно из прошлого урока, а что изменилось - сравни about.html и index.html (да, я просто устал и не могу все здесь расписывать для себя в будущем)

    13. В текущей страницы ссылки в navbar не работают. Исправляю: где она находится? В base.html. ==> 

        1. Нахожу кнопку HOME (или ссылку, как больше нравится). И в параметре href я удаляю прямую ссылку - index.html и заменяю ее на href="{% url "name" %}", где name - имя url (index в данном случае, 173 
        строчка этого файла тебе в помощь.)

        2. Проверяю - работает. Делаю так же со всеми готовыми html документами



    14. Но наверное ты понимаешь, что это не правильно - все url адреса всех приложений находятся в одном файле? Надо это исправить, что бы в основном urls.py хранились лишь ссылки на urls.py приложений:

        1. Создаю в папке приложения (main) файл urls.py и копирую в него все из основного файла urls.py.

        2. Нужен ли мне конкретно в этом приложении admin? нет. Значит импорт admin и path('admin') я удаляю. 

        3. Перед urlpatterns создаю переменную app_name и присваиваю ей имя приложения.

        4. Дальше работаю с основным urls.py: Первым делом я удаляю иморт views из main. 

        5. Теперь я удаляю ссылки на переменные из файла views и заменяю их следующим:

            1. Так как в приложении, с которым я сейчас работал, лежит index.html, то первым аргументом в path будет '' (index - основная страница. Тогда, что бы путь на нее был https://domen.com/, а 
             не https://domen.com/index/, то путь должен быть не 'index/', а '').

            2. Вторым аргументом, вместо views.index/views.about, я записываю функцию include, в которую передаю путь до urls.py - имя_приложения.urls , а вторым значением - namespace со значением - имя 
             приложения



        В итоге в списке urlpatterns в основном urls.py должны лежать такие значения (в данном случае):

                    path('admin/', admin.site.urls),
                    path('', include('main.urls', namespace='main'))

        

        Как и планировалось, в нем лежит лишь ссылка для админ-панели, и на urls.py другого приложения



        6. Теперь старые ссылки не работают. Исправляю: иду в файл base.html и подправляю ссылки: они должны иметь формат namespace:nameurl, где:

            namespace - значение namespace, 
            nameurl - имя url адреса. 
            
            

            В данном случае получилось:

                href="{% url "main:about" %}"





ПРИЛОЖЕНИЕ GOODS:

    1. Создаем его (python manage.py startapp goods) и регестрирую (в settings, INSTALLED_APPS).

    2. Создаю контроллеры catalog для отображения каталога и product - для отображения каждого продукта. 

    3. Создаю urls.py для этого приложения, копирую в него все из urls.py приложения main, и подправляю (адаптирую) его для goods:

        1. Меняю импорт - views в этом файле я импортирую не из main, а из goods 

        2. Какие страницы должны быть в этом приложении? Их может быть много, но обязательно будет каталог и страница товара. Тогда, меняю url адресса под них:
            
            Для 1-й строки '' оставляю, вместо views.index - views.catalog, name оставляю.  
            Для 2-й строки вместо вместо about/ - product/, вместо views.about - views.product, вместо name='about' - name='product'.



    4. Теперь нужно добавить адреса из goods в общие адреса:

        1. Добавляю в LEARN_DJANGO_APP.urls.py следущую строку:
        
            path('catalog/', include('goods.urls', namespace='catalog'))



    5. Создаю папки для html документов (templates\goods) и переношу из верстки в него документы этого приложения - catalog.html и product.html, а так же настраиваю: 

        1. Расширяю html - {% extends "main/base.html" %}

        2. Подгружаю статику - {% load static %}

        3. Открываю catalog.html из верстки и смотрю уникальные части: 

            1. В block footer вставляю весь footer 

            2. В block content вставляю контент на странице и пагинацию (можно найти по комментарию)



        4. В product.html footer нету,  так что:

            1. В block content вставляю контент на странице



    6. Дописываю контроллеры: 
        
        1. return render(request, 'goods/catalog.html')

        2. return render(request, 'goods/product.html')



    7. Теперь при обновлении сайта и перехода на нужную ссылку по url все работает, но не работают ссылки. Исправляю:

        1. Захожу в base.html, и ищу, где должны быть ссылки на каталог. Дальше их url меняю: href="{% url "catalog:index" %}"


    КАК МОЖНО ЗАМЕТИТЬ, ВООБЩЕ НИЧЕГО НОВОГО Я СЕЙЧАС НЕ СДЕЛАЛ, ВСЕ ТО ЖЕ, ЧТО Я ДЕЛАЛ В ПРИЛОЖЕНИИ MAIN.



    8. В файле catalog.html находятся "карточки" товаров. В них почти весь код повторяется, меняются только значения. Что я должен сделать, если много одинакового кода в одном файле? Воспользоваться циклом:

        1. Открываю файл views, контроллер для catalog, context, и создаю еще одну пару ключ-значение, goods:list. List - список из словарей, в каждом из которых - те уникальные значения из html документа. 
         Пока что, в качестве обучающего примера, данные я буду хранить там, хотя это и не правильно. Позже эти данные будут в БД. 

        2. Этот список из словарей уже есть в верстке - other_files => goods_list.py. Этот код я просто вставляю в мой context в контроллер.

        3. Перехожу в catalog.html, и удаляю все карты кроме 1.

        4. Создаю шаблонный тег for product in goods (то есть какая-то переменная в goods (goods находится в контексте))

        5. Меняю имя товара на product.name в плейсхолдере {{ product.name }}, и так же с описанием и ценой.

        6. Обновляю, проверяю - все работает.



    9. Дальше добавляю картинки - <img src="путь"> заменяю на <img src="{% static product.image %}" для фото товара, а для фото корзины - src ="{% static "deps/icons/catr-plus.svg" %}"

        Обновляю, проверяю - опять же, все работает.





БАЗЫ ДАННЫХ:

    DJANGO ORM - Object Reletional Mapping (Объектно-релеационное сопоставление), это способ как описать с помощью ООП таблицу, что должна быть создана в бд и какую информацию она в себе хранит
    (автоматически генерирует sql запросы под соответствующую базу данных)

    В проекте уже созданна бд - db.sqlite3. Что бы просмотреть ее, можно воспользоваться приложением db browser for sqlite . Как видно, она пустая. Но помнишь ошибку при запуске сервера? Что есть
    18 не примененных миграций. Сейчас я их применю:

        1. В терминал: python manage.py migrate.



    Еще раз открою db.sqlite3 . Вижу - создано 11 таблиц. 

    Теперь создам свою таблицу Categories: это нужно делать в файле models.py:

        1. Как уже стало понятно, работа осуществляется с помощью классов. Создаю класс Categories, который всегда должен наследоваться от класса Model - по умолчанию в models.py импортируется models. 
        Из models мы создаем ссылку на класс Model - models.Model. 

            class Categories(models.Model):



        2. Создаю аргументы класса - name и slug. В базах данных, в отличии от Python, необходимо указывать тип данных. Все их учить не нужно. В документации, если в поиске вбить Model field reference,
        справа в баре будут field types - те самые типы данных. Просто нужно посмотреть, какой тип мне нужен для конкретного аргумента. 

        3. Для имени используется тип CharField (тип для небольших строк) - вызываю его из импортированного автоматически models. Так же необходимо указать параметры:
           
            max_length = x - максимальная длина строки 
            unique = True - должно ли быть имя каждой категории уникальным



        4. Для slug используется тип SlugFiels - вызываю его. Передаю параметры: 
           
            max_length = x 
            unique = True
            blank = True 
            null = True    (последние два параметра позволяют быть полю пустым)



        5. Поле id создавать не нужно - django создает его автоматически. 

        6. Что бы имя таблицы было не appname_tablename, а просто tablename, стандартной практикой является делать вложенный класс Meta, атрибут которого - db_table: str = 'name_of_table'

        7. Создаю миграцию и применяю ее - python manage.py makemigrations, python manage.py migrate. Если вдруг мне не понравились изменения - я могу удалить db.sqlite3 и созданную python миграцию
        после применения моей таблицы - в папке migrations удаляю файл xxxx_inital.py. Теперь при запуске сервера опять будет сообщение - 18 непринятых миграций. 

        8. Теперь я хочу авторизоваться в админке и посмотреть, как выглядит бд в ней. В html у меня есть сылка, но она не рабочая. Для начала я ее активирую (ничего нового)

            1. Открываю base.html, нахожу ссылку "Панель администратора", и одно отличие - путь всегда будет admin:index. То есть получилось: href = "{% url "admin:index" %}"

            2. Теперь нужно создать администратора, или суперпользователя. Для этого в термила надо вписать python manage.py createsuperuser. 

            3. Дальше, если залогиниться в админ панели, то я увижу 2 ссылки: нажму на users. Пока что там только 1 пользователь - мой супер юзер. Если нажать на него, то 
             я увижу какие-то его настройки: никнейм, имя, фамилия, почта, активный/неактивный, права рут и тд.

            4. Однако моей таблицы там нету. Она просто скрыта, и для ее отображения в админ панели надо ее импортировать: в файле admin.py нужно импортировать мою таблицу (класс),
             а потом передать ссылку на нее в метод admin.site.register(ссылка на класс (таблицу))

                    from goods.models import Categories 
                    admin.site.register(Categories)

                    Теперь после рестарта сервера я увижу свою таблицу Categories в админ панели



            5. Но есть проблема: названия таблиц могут быть понятны мне - программисту, но не администратору. И с английским он может быть плохо знаком. Так что надо адаптировать админ панель 
                для удобной работы будущих администраторов: поменять язык на русский, изменить имя таблиц (только для админ панели, в коде их имена остаются те же)

                1. В основном приложении открываю settings, и меняю LANGUAGE_CODE на ru. Теперь текст админ панели и созданные по умолчанию таблицы на русском.

                2. Открываю models.py, и под db_table в классе Meta записываю переменные: 
                    
                    verbose_name: str = 'Категории', - альтернативное имя во ед. числе
                    verbose_name_plural: str = 'Категория' - альтернативное имя в множ. числе
                


                3. Так же для каждого поля в таблице можно тоже дать свое имя: просто передаю их в классе Categories в качестве параметра. (только в ед.ч)

                4. Теперь нужно дать имя названию таблицы. Для этого нужно в файле apps.py опять же verbose_name



    Создаю таблицу Products:

        1. Анологично создаю класс, передаю в него ссылку на модель, ниже класс Meta с именем, альт.именем и альт.именем во множественном числе. 

        2. Из полей (аргументов) я копирую name и slug из таблицы Categories, а так же добавляю:

            1. description - описание. Тип - textField, позволяет хранить больше символов, чем CharField

            2. image - фото товара, тип ImageField, позволяет хранить изображение (точнее ссылку на него). Новые параметры - upload_to='' (откуда загрузить фото)

            3. price - цена, тип DecimalField - число с плавающей точкой. Новые параметры - default (значение по умолчанию), max_digits макс. символов до точки, decimal_places - макс. символов после

            4. discount - скидка, все то же, что и в price, за исключением verbose_name

            5. quantity - кол-во товара, тип PositiveIntegerField (положительные целые числа).

            6. category - Это уже прикрепление к таблице Categories. тип - ForeignKey, Новые параметры:

                1. to=  - к чему привязать (Ссылка на таблицу (класс))
                2. on_delete = что делать если таблица, к которой привязан, удалена. Есть 3 варианта:
                            
                    1. models.PROTECT. Запретить удалять таблицу, пока к ней что-то привязано.
                            
                    2. models.CASCADE. При удалении таблицы удаляются все привязанные к ней пункты.
                            
                    3. models.SET_DEFAULT, default='xxx'. При удалении повязанным пунктам задать значение default.



            7. Авторизую таблицу в админ панели - так же, как и ранее.

                1. Импортирую в admins.py таблицу(класс) Products

                2. admin.site.register(Products)



            8. Теперь, для создания и применения миграций, необходимо установить библиотеку Pillow - я же использовал в качестве параметра image, вот эта библиотека и обрабатывает фотографии.

                1. pip install Pillow 

                2. python manage.py makemigrations

                3. python manage.py migrate

                Можно проверить - в админ панели таблица отображается верно.



    CRUD операции: Классы нужны не только для создания таблиц, через них мне предоставляется api для работы с ORM системой, что позволяет мне делать с таблицей CRUD операции (Create Read Update Delete) 

        1. Для начала поработаю с терминалом, потому что в контроллерах будет немного неудобно понять принципы работы, взаимодействия с талицами через классы. 

            1. Обращаюсь через manage.py к shell - это консоль самого Django, в которую подтягивается весь проект => python manage.py shell

            2. Как и в обычном файле, импортирую класс Categories => from goods.models import Categories 

            3. Через этот класс можно работать с таблицей. Создадим объект ... допустим x. => x = Categories()

            4. Присвою значение имени - офис => x.name='Офис'

            5. Посмотрю через db browser, есть ли пункт с именем Офис в таблице Categories. нет

            6. Сохраняю переменную => x.save()

            7. Опять посмотрю эту таблицу через db browser - и вот, она сохранилась.

            8. Выведу этот объект x в терминале. => x    Вывод - <Categories: Categories object (1)> (1 - его id)

            9. Задам slug объекту x. => x.slug = "It's slug"

            10. Сохраню, зайду в db browser и посмотрю - сработало.

            11. В терминале нет подсветки синтаксиса и автодополнения, что мешает. И хоть конкретно с бд долго через терминал я работать не буду, но в общем это будет полезно добавить:

                Сначала я выйду из Django Shell => exit()

                pip install ipython

                Закрываю терминал и открываю заново

                Ввожу просто ipython для запуска (если я запускаю Django shell, ipython подтягивается автоматически). Для выхода из ipython пишу quit()



            12. Запускаю заново shell и работаю в нем

                1. Импортирую из goods.models таблицу Categories 

                2. Создаю объект более стандартным способом:

                    Categories.objects.create(name='Кухня', slug='URL_Kuhnya')
                    
                    Таким образом ничего сохранять не надо, это делается автоматически.



                3. Проверяю - новый способ работает. 

                4. Теперь сохраню все данные из таблицы Categories в переменную ... x 

                    x = Categories.objects.all()



                5. Выведу x и посмотрю, что он из себя представляет и что в нем лежит:

                    x 
                    
                    Вывод:

                        <QuerySet [<Categories: Categories object (1)>, <Categories: Categories object (2)>]>

                    То есть x - массив, в котором лежат объекты таблицы Categories с id 1 и id 2



                6. Если x - массив, то я попробую вызвать элемент с индексом 0:

                    x[0]

                    Вывод: <Categories: Categories object (1)>



                7. x - это QuerySet. Его особенность заключается в возможности повторного применения одних и тех же или различных методов много раз.



            Получение категорий товаров из БД:
                
                1. Захожу в админ панель, категории, и удаляю те, что там есть.

                2. Выбираю добавить категорию (ну или как там я назвал объект), пока что заполняю только имя - Все товары

                3. Однако в админ панели имя отображается неверно - Categorie object(3). И дело не в id = 3, ведь даже после удаления из таблицы id замораживается. Дело в имени - надо его поправить.

                    1. Открою models.py и наведусь на наследуемый мною класс - Model. Нажму f12. Если пролистаю в открывшемся коде чуть ниже, то увижу метод str, возвращающий object, classname, pt, 
                    где object - объект, self.__class__.__name__ - имя класса, pk - primary key, или первичный ключ. pk можно назначить на любой аргумент и тип данных, но делать этого не нужно. 

                    2. Однако можно переписать у себя в классе этот метод - в return напишу более читабельную для админа надпись:
                        
                        Для Categories:

                            def __str__(self) - str: 
                                return self.name 

                        Для Products:

                            def __str__(self) -> str:
                                return f'{self.name} Количество - {self.quantity}' 

                        Можно запустить сервер и проверить



                4. Отлично, работает. Теперь нужно заполнить slug (url): 

                    1. В файле admin.py я регистрировал таблицы в админке. Проблема в том, что при такой регистрации нельзя вносить никаких изменений в отображаемое в админ панели. 

                    2. Я создаю свой класс CategoriesAdmin, который наследуется от admin.ModelAdmin (ссылка), а так же декорирую его декоратором @admin.register(Categories)

                        @admin.register(NameOfTable)
                        class NameClass(admin.ModelAdmin):
                            код 



                    3. Создаю в классе аргумент prepopulated_fields, и передаю в него, какие поля заполняются автоматически: Передаю словарь с ключем slug и значением кортеж name 

                        prepopulated_fields = {'slug':('name',)}



                    4. Сохраняю изменения, удаляю созданную ранее категорию и создаю новое: теперь, как только я пишу имя, slug(URL) заполняется автоматически. Если не нравится заполнение - можно написать
                    самому. 



                5. Посмотрю, какие же у меня есть категории (вдруг у меня деменция и я не помню).

                    1. Захожу в приложение main, выбираю templates и base.html. Ищу категории (у них кнопка - catalog:index)



                6. Добавляю их в в таблицу через админку.

                7. Добавляю таблицы в html шаблон из БД:

                    1. Открываю views в файле main (так пока что удобнее)

                    2. Перед контроллерами импортирую таблицы: 

                        from goods.models import Categories



                    3. В контроллере index создаю переменную categories и передаю в нее все из объекта Categories:

                        categories = Categories.objects.all()



                    4. В контексте создаю ключ - значение 'categories':categories 

                    5. В base.html все категории кроме 1 удаляю, и записываю шаблонный тег for: 

                        {% for categorie in categories %}
                            та категория, что я не удалил 
                        {% endfor %}



                    6. В тег a передаю плейсхолдер с именем категории:
                        
                        <li><a ...> {{ categorie.name }} </a></li>



                    7. Проверяю работоспособность



                8. Так же как я делал с категориями, добавляю продукты через админку в бд (пока что без картинок)

    РЕЗЕРВНАЯ КОПИЯ БД: Стоит подумать о том, что же делать, если с бд что-то случится. На этот случай можно создать резервную копию: 

        1. Создаю в корне папку fixtures - в ней будут лежать данные с таблиц. 

        2. Внутри создаю папку для приложения - что бы не мешать бд с разных приложений 

        3. В терминале пропписываю: python manage.py dumpdata приложение.имя_таблицы -> fixtures/имя_приложения/имя_для_файла.json 

            python manage.py dumpdata goods.Categories > fixtures/goods/cats.json 
            python manage.py dumpdata goods.Categories > fixtures/goods/prods.json 



        4. Теперь, если все сделал верно, бд можно переместить для теста куда-нибудь и восстановить ее:

            1. Переименовываю db.sqlite3 на db_old.sqlite3

            2. Перемещаю старые миграции куда-нибудь

            3. Делаю миграции и применяю их (python manage.py makemigrations, python manage.py migrate)

            4. Заново создаю супер юзера (python manage.py createsuperuser)

            5. Загружаю в созданную бд сохраненные данные таблиц:

                manage.py loaddata fixtures/goods/cats.json 
                
                manage.py loaddata fixtures/goods/prods.json 



            6. Проверяю. 
                P.S. У меня возникла с этим этапом проблема, которую я в теории понимаю как можно решить, но пока что не до этого. Поэтому настоятельно рекомендую сохранить все старые файлы. 

                Возможное решение: предположительно проблема с файлом settings.json: я его не добавлял к себе, т.к мне не нравится оформление среды, но скорее всего там прописаны параметры для 
                корректной работы fixtures. Этот файл лежит в папке other_files верстки, можно попробовать найти необходимые строки там и модифицировать пользовательский settings.json / заменить его.
                Не тестировал

                python -Xutf8 ./manage.py dumpdata goods.Categories > fixtures/goods/categories.json - использование такой записи в 3 пункте решает проблему (принудительно использую кодировку
                utf-8)



    ЗАПРОСЫ ЧЕРЕЗ ORM СИСТЕМУ: Познакомлюсь более подробно с запросами через ORM систему. 
    
        1. Для этого нужны сторонние расширения:

            1. перехожу на сайт pypi.org и ищу django-debug-toolbar.

            2. Устанавливаю его: pip install django-debug-toolbar

            3. Возвращаюсь на сайт и смотрю, как установить его в файл: 

                1. добавляю в Installed_apps (в settings.py) "debug_toolbar"

                2. Добавляю в основной urls.py:

                    from name_app.settings import DEBUG

                    if DUBUG:
                        urlpatterns += [ path("__debug__/", include("debug_toolbar.urls")) ]



                3. Добавляю дополнительное ПО:

                    1. В settings.py в MIDDLEWARE добавляю "debug_toolbar.middleware.DebugToolbarMiddleware"

                4. Настраиваю разрешенные ip адреса:

                    В том же settings.py добавляю где-то под staticfiles_dirs, то есть ближе к концу файла, следующий массив:
                    
                        INTERNAL_IPS = [
                            "127.0.0.1",
                        ]



                5. Запускаю сервер, захожу на него - и вижу что работает. (панель появилась)



        2. Работа с debugsqlshell: 
        
            1.После установки django-debug-toolbar, через manage.py можно вызвать debugsqlshell. Этот терминал будет выводить. Внешне она ничем от прошлой не отличается, но в ней 
             видны ошибки и то, что делают sql запросы.



            2. Импортирую таблицу prducts

                from goods.models import Products



            3. Смотрю все записи в таблице: 

                Products.objects.all()



            4. Отфильтрую - выберу например, только те поля в таблице, у которых id = 2

                Products.objects.filter(id = 2)



            5. Отсортирую товары по цене:

                Products.objects.order_by('price') (по возрастанию)
                Products.objects.order_by('-price') (по убыванию)



            6. Отфильтрую - выберу продукты с ценой ниже 300.

                Products.objects.filter(price__lt=300).order_by('price')    (gt - больше чем, gte - больше или равно, lt - меньше чем, lte -меньше чем)

                    Дословно: из объектов таблицы Products отфильтровать все, где price меньше 300 и отсортировать по возрастанию цены.

                    Другие аргументы: 

                        iexact (полное совпадение без учета регистра), 
                        exact (полное совпадение), 
                        contains (содержит в себе),
                        icontains (содержит в себе без учета регистра), 
                        & (аналог and в python)
                        | (аналог or)
                        Примечание: в sql3 без учета регистра НЕ РАБОТАЕТ, однако работает в основных бд, которые уже работают на сервере.



            7. Отфильтрую с ценой от 300 до 500. 

                Products.objects.filter(price__gt=300) & Products.objects.filter(price__lt=500)

                Для сортировки К ПОСЛЕДНЕМУ запросу (тот что после &) так же прописываю .order_by('-price')

                Аналогичной будет запись:

                    Products.objects.filter(price__gt=300).filter(price__lt=500).order_by('-price')



            8. Отфильтрую по наличию цены ниже 50 или в описании продукта есть "диван"

                Products.objects.filter(price__lt=50) | Products.objects.filter(description__contains="диван")



            9. Отфильтрую по категории: только те товары, которые принадлежат таблице category и имеют id 6. (Это возможно, т.к я ее привязывал к таблице Products)

                Products.objects.filter(category__id="7")



            10. Этот id принадлежит категории гостинная. Можно обратиться по имени:

                Products.objects.filter(category__name="Гостинная")



            12. Логично, что к этим товарам тоже можно применить сортировку, фильтры и тп 

                Products.objects.filter(category__name="Гостинная").order_by("price")



            13. Теперь можно сохранить какие-то данные в переменную. Допустим, я помещу товары категории кухня, сортированные по цене в переменную goods 



                1. goods = Products.objects.filter(category__name="Кухня").order_by("price")

                2. Как видно, запроса в бд не произошло. Вызову goods:

                    goods 



                3. Теперь произошел запрос. То есть это - уже знакомые мне ленивые вычисления.

                4. Часто нужно узнать, получены ли какие-либо данные из запроса, или я получаю пустой QuerySet. Для этого: 

                    goods.exists() - В самом низу возвращает True/False, То есть получены данные/ не получены



                5. Если ты помнишь, то QuerySet - список => можно вызвать x элемент из списка/ записать его в переменную (где x - индекс.)

                    goods[x]
                    first_element = goods[0]



                6. Естесственно, я могу узнать имя элемента, его slug или id итд. 

                    first_element.slug 



                7. Получу имя и цену всех товаров:
                    
                    for i in goods:
                        print(f'{i.name}, {i.price}')

                    (P.S что бы запустить, зажимаю Tab и 2 раза быстро нажимаю Enter)



        3. Применение: поучился, посмотрел как работает - применяю на практике

            1. Перехожу в views.py (в goods), и убираю в контроллере каталог из контекста словарь goods (точнее его значение, ключ убирать не надо)

            2. Импортирую модель в переменную goods:

                from goods.models import Products 



            3. Записываю весь QuerySet в переменную:
                goods = Products.objects.all()



            4. Передаю goods в словарь к ключу "goods" как значение.

            5. Запускаю сервер и проверяю, отображается ли все как надо. (Да) Могу даже посмотреть, какой sql запрос был сейчас сделан. (В панели нажимаю на SQL). Увижу в переводе: выбрать все из Products



ДОРАБОТКИ В ПРИЛОЖЕНИИ GOODS:

    1. Необходимо создать структуру для подключения фотографий

            1. Создаю папку media в корне проекта (в дальнейшем эту папку нужно закинуть в .gitignore, т.к git плохо работает с изображения.)

            2. Открываю файл settings.py, и под staticfiles_dirs указываю, где django искать медиа файлы:

                MEDIA_URL = 'media/'



            3. А теперь указываю путь до изображений:

                MEDIA_ROOT = BASE_DIR / 'media'



            4. Теперь заставляю джанго обслуживать медиа-файлы: 

                1. Открываю urls.py в основном приложении 

                2. Открываю документацию джанго, и в поиске вбиваю url dispetcher, кликаю на первую ссылку - там есть объяснение того, что я уже сделал в этом файле и что будет дальше. 

                3. Если поискать, то я увижу, что надо добавить:

                    1. from django.conf.urls.static import static

                    2. ВМЕСТО  from LEARN_DJANGO_APP import DEBUG   ЗАПИСЫВАЮ   from LEARN_DJANGO_APP.settings import settings

                            P.S. На самом деле, это не корневой файл settings, корневой, как видно из документации, лежит по пути django.conf (from django.conf import settings). Так что если с этими settings
                            что-то не выходит, можно попробовать изменить это через корневой settings.



                    3. где if DEBUG меняю на if settings.DEBUG и в его тело добавляю: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)



            5. Запускаю серевер и через админку добавляю фотографии товара (они есть как и в верске, так и в статике проекта). Так же можно некоторым товарам добавить скидку (в %)

                Теперь, если вернуться к коду, то в папке media появилась папка goods_images, а в ней - изображения. Помни, в бд лежат только пути. Откуда появилась goods_images?
                помнишь, что в models.py я указывал в аргументе image параметр upload_to? Вот то, что я передал в этот параметр, и есть имя папки. 



            6. Однако на странице пока изображений нет. Это потому что я загружал ранее изображения из статики. Так что:

                1. Открываю catalog.html, и в цикле for в теге img с классом catd-img-top удаляяю {%static product.image %}, заменяя его плейсхолдером {{ product.image.url }}.

                2. После этого возникнет ошибка, если я добавил не все фото. Что бы этого не произошло, этот тег img я загоняю в шаблонный тег if с условием product.image 

                    {% if product.image %}
                        <img ...> 
                    {% endif %}



                3. Вот теперь при перезагрузке страницы у меня все запустится и те изображения, что я уже добавил, отобразятся.

                4. Но ведь же некрасиво, когда нет изображений? в таком случае, надо добавить промежуточный вариант:

                    1. В catalog.html после <img...> добавляю шаблонный тег else, копирую тот тег img и вставляюю под else. 

                    2. В этом теге меняю {{ product.image.url }} на лежащую у меня в статике картинку для ненайденных картинок:
                        
                            <img src="{% static "deps/images/Not found image.png" %}" class="card-img-top" alt="...">



    2. Отображение цен со скидкой:
    
        Что бы цены были отображены с размером скидки, изменить id на более... На имеющие значения. и тп.

        1. Открываю models.py (goods)

        2. Создаю метод display_id, - то, как будет отображаться id на сайте. Возвращать этот метод будет id товара в 5 символов, то есть самый правый - это его id, а слева нулями буду добивать до 5 символов

            def display_id(self):
                return f'{self.id:05}'            , то есть self.id должен состоять из 5 символов



        3. Перехожу в catalog.html и заменяю поле id плейсхолдером {{ product.id }}. Теперь у меня на сайте просто отображается id продукта одним числом - 1, 2, 3 и тп. 

        4. Заменяю в плейсхолдере product.id на product.display_id. Теперь отображается id так, как и планировалось.

        5. Теперь реализую скидки: возвращаюсь в models.py, создаю метод sell_price - для отображения цены со скидкой. 

            def sell_price(self):
                if self.discount:
                    return round(self.price = self.price * self.discount / 100 , 2)               Цена со скидкой

                return self.price                                                                 Цена без скидки



        6. Возвращаюсь в catalog.html, удаляю комментарий (удаляю плейсхолдер comment), и запихиваю все что было закомментировано в if. Потом, в else закидываю просто плейсхолдер self.price 

        7. Где был закомментированный код, в 1 теге p написано 100 - это цена. Меняю ее на цену продукта: {{ product.price }}

        8. Во 2 теге p меняю цену на {{ product.sell_price }}

        9. В 3 теге меняю кол-во процентов скидки на product.discount

        10. Вернусь на сайт и проверю - работает. 



    3. Отображение выпадающего меню "каталог"
        
        На странице каталога нету менюшки "каталог". Нужно исправить, но конечно копировать из контроллера индекс во все другие контроллеры неправильно. Поэтому, для начала, немного теории:     
        теги бывают "простые" и "включащие":

            Простые - простсо предоставляют возможность разместить/получить из разметки какие-то данные 
            Включащюие - включают дополнительно в разметку, в шаблоне дополнительный html код дополнительно к тому, что они делают.



        1. Создаю в приложении gooods папку templatetags. 

        2. В этом файле я создаю такой же файл, как и в migrations - __init__.py 

        3. Создаю файл, что будет хранить мои шаблонные теги - goods_tags.py 

        4. Сразу вырежу из контроллера index запрос к бд и catigories из контекста удаляю.

        5. Открываю созданный файл .py, и создаю функцию tag_categories:
            
            def tag_categories()
                return Categories.objects.all()



        6. Имопртирую:
            
            from django import template 
            from goods.models import Categories



        7. Регистрирую мой шаблонный тег:

            register = template.Library()



        8. Получился декоратор. Декорируем метод:

            @register.simple_tag()
            def ...



        9. Теперь код, как можно понять, "сломан". В base.html я перебирал categorie из контекста. Надо это исправить: 

            1. открываю base.html и записываю в самом начале, под load static:

                {% load goods_tags %}



            2. Опускаюсь к циклу для размещения категорий, и над ним записываю мой шаблонный тег: 

                {% tag_categories as catigories %}



        10. Все, надо запустить и проверить. Теперь каталог работает везде, где должен. На этом этапе сделан коммит.

КОНВЕРТЕРЫ В URL АДРЕССАХ

    Открываю документацию и в поиске пишу: url dispatcher

    Вижу, что url адреса не должны быть все написаны в Urls, они могут быть гибкими и автоматическими. 

    У меня есть контроллер product, и в urls.py есть url маршрут, отвечающий за этот контроллер. Нынешняя задача - сделать ссылки на каждый отдельный продукт:

        1. Разберу типы конвертеров:

            1. Str - принимает любую строку кроме / 

            2. int - любое значение, которое можно конвертировать в целочисленное значение

            3. slug - используется для фрагментов url адрессов, используя буквы, /, - ;


            
        2. Как ими пользоваться:

            1. Поработаю с контроллером product: в urls.py изменяю путь на product/<int:product_id> 

            2. В контроллере добавляю аргумент product_id, и записываю - что это: product = Products.objects.get(id.product_id)

            3. Создаю контекст: context = { 'product':product, }

            4. Перехожу в product.html, и размещу информацию о товаре:

                1. Размещу миниатюры - в src размещаю в плейсхолдере изображение - <img src = " {{ product.image.url }} ">

                2. Ниже так же есть тег Img для появления изображения при клике на него - опять же размещаю: <img src = " {{ product.image.url }} ">

                3. Меняю id - как и в прошлый раз, <p clss ...> id: {{ product.display_id }} </p>

                4. Изменяю название - {{ prduct name }}

                5. Изменяю описание - {{ product discription }}

                6. Указываю цену сразу со скидкой - {{ product.sell_price }}



            Что я сделал: в первом шаге указал, что путь до товара с опред. id это /catalog/product/product_id. Во втором шаге, указал в контроллере, что же такое product_id - это аргумент, который 
            передается в контроллер. Он равен id, который я получаю из бд в этой строке - products = Products.objecst.get(id=product_id). Еще проще - products_id, допустим, равно 3. Тогда, если я в 
            браузере перейду по url /catalog/products/3, то я перейду на товар с id 3. Затем я создал в контексте ключ "product" со значением - product для использования в html разметке. И, в конце,
            я указал имя, описание, цену, картинку для самого продукта. (в product.html, то есть я делал это для страницы самого продукта)



        3. Теперь нужно сделать такой, что бы при нажатии на саму карточку товара, на его ссылку, открывалась страница этого товара. Реализую:

            1. Где у меня лежат все карточки? Правильно: в catalog.html. Открываю его 

            2. Смотрю, где у меня в карточке должен быть Url адрес на товар.

            3. Нахожу, и маршрут указываю не через плейсхолдер, а через спец. тег Url: <a href="{% url "catalog:product" product.id %}"

                Этот процесс называется обратное разрешение url адрессов: url это просто функция, принимающая такие аргументы, как catalog:product и product.id: 
                    Есть namespace - catalog. То есть надо проверить, есть ли такой в urls.py: ага, есть: ему следует вот такой префикс - / (у меня же 'catalog/') => путь url уже такой: /catalog/ .
                    затем указано: namespace - product. Ага, значит, ищу в другом urls.py product. Нашел: такой есть в goods/urls.py. Он имеет префикс /<int:product_id>. То есть путь уже 
                    /catalog/product/product_id, где product_id - целочисленное значение. А почему нет доменного имени? Ну например https://mysite.com/catalog/product/3 ? А потому что браузер сам 
                    догадается, что его нужно добавить, и в конце концов получится именно такой url адрес. (В данном случае вмпсто mysite.com - мой локал хост (127.0.0.1:8000))



            4. Теперь я могу открыть сайт и просмотреть: точно, ссылки работают! 



        4. Однако, согласись, что url адрес теперь непонятен: https://mysite.com/catalog/product/3 . https:// - основной протокол. mysite.com - доменное имя. catalog - понятно, что это каталог. 
        product - опять же, понятно, что это продукт. А что такое 3 ? Непонятно. Надо это исправлять

            1. Помнишь, что я в бд добавлял некие "слаги"? Пришло их время! 

            2. Открою catalog.html, и меняю в ссылке на продукт product.id на product.slug. 

            3. В urls.py вместо конвертера int напишу slug, ну и product_id поменяю на product_slug, что бы было логичнее. 

            4. В контроллере аргумент меняю с product_id на product_slug, и в параметре product заменяю id = product_id на slug = product_slug. 

            5. Зайду на сайт, выберу любую карточку - и вот: url сразу стал понятнее: никаких непонятных чисел, а название нужного товара!

            6. Никто не мешает сделать поиск и по id и по slug - тогда в urlpatterns вставлю прошлую версию product/ , (не удаляя новый), и в контроллере в качестве аргументов задам значения 
            для product_id и product_slug по умолчанию false, и через if выполню проверку: если поиск по slug - то и в контекст передаю slug. если product_id - То передаю id. Важно заметить: 
            в Urls.py первым должен идти конвертер int, а потом уже slug, иначе будет ошибка. Я этого реализовывать не буду, так как в этом в данном проекте нет смысла, но, например, в том же ВК 
            найти страницу человека можно как с помощью id, так и с помощью коротокого имени - это как пример применения. 



        5. Теперь нужно сделать это же, но для категорий в выпадающем меню:

            1. Открываю base.html, и ищу там Каталог (есть комментарий)

            2. Нахожу тег a с сылками на категории товаров: если ты помнишь, я еще там делал тег for для categorie.name, но ссылка на них всех одна - categorie:index, то есть
            url имеет вид и для гостинной, и для спальни, и для остальных http://domen.com/catalog/ (т.к index, если помнишь, имеет маршрут /). надо исправить: в бд уже есть 
            slug для них, и, как и в прошлый раз, добавляю его: в цикле for есть catigorie - это каждая категория из бд. Мне нужен ее slug => дописываю categorie.slug

            3. Т.к html catlalog находится в приложении goods, в urls.py этого приложения, поле url для index вместо пустого записываю мой slug: <slug:category_slug>

            4. Теперь добавляю его в контроллер: Для начала, я сделаю проверку. Если выбрано все товары - if category_slug == 'all', то получить все из Products. Иначе, отфильтровать из 
            Products только только те товары, у которых slug равен моему category_slug. Как ты помнишь, при фильтрации я не просто записываю, что slug = category_slug, а 
            название таблицы, два подчеркивания и параметр равен моему параметру: category__slug == category_slug.

                P.S. Я не знаю, на каком этапе, но у меня сейчас возникла путаница с categories и category. Categories - это имя класса, с помощью которого я создаю таблицу, а category - 
                это имя таблицы



            5. Если на странице не будет ни одного товара, то он увидит стремное отображение пустой страницы. Поправить это можно 2 способами: 1 - это сделать проверку. 
            Так как в контроллере переменная goods - это QuerySet, то можно выполнить проверку goods.exists. И через if, если QuerySet пустой, отрендерить другую страницу:

                if not goods.exists():
                    render(request, 'goods/pustaya_stranichka.html', context)



            Либо же, можно выдать пользователю ошибку 404 - page not found. Вообще, метод выше на мой взгляд лучше, но пока я учусь, я следую автору и воспользуюсь этим методом:
                goods = get_object_or_404(Products.objects.filter(category__slug = category_slug)). Таким образом, если QuerySet пустой - то 404, если нет - то рендер страницы.
                Эту функцию надо импортировать из django.shortcuts 

                P.S. Как оказалось, это немного устаревшая информация. При таком использовании будет вылезать ошибка, если у вас более 1 товара в категории. Эту функцию заменяю на
                get_list_or_404



ПАГИНАЦИЯ
    Пагинация - если я открою сайт, то снизу увижу 1, 2, 3 и тп страницы. Вот это и есть пагинация

    1. В документации впишу: pagination. Вижу, что есть класс Pachination, который позволяет автоматизировать отображение товаров на конкретной странице. 

    2. В контроллере catalog завожу переменную paginator, и передаю в нее класс Paginator. Его аргументы - мой QuerySet (goods) и количество товаров на странице - пусть будет 3. 

    3. Получаю эти товары: создаю переменную current_page , и передаю в нее paginator, его метод page и номер страницы - 1. 

    4. В контексте вместо goods я в ключ goods передаю эту переменную - current_page. 

    5. В терминале выдается предупреждение - что пагинатор может выдавать некорректные данные, ведь не указан способ сортироваки. Надо это исправить, хоть сейчас это не на что и не влияет:

        1. Открываю модели - goods => models, и в class Meta создаю аргумент oredering, а значение - кортеж, в котором, пока что, лежит только id ( ordering = ("id",) )

            Теперь запущу сервер, и предупреждение не появляется 



    6. Нужно реализовать получение страницы через контроллер:
        
        Хотя способов и много, я воспользуюсь таким (вообще, плохой способ):

        1. в контроллер необязательным аргументом передам page с базовым значением 1

        2. Передаю этот аргумент как аргумент current_page

        3. В urls.py добавляю еще 1 элемент в список urlpatterns: копирую 1, и добавляю после / <int:page>/

            Теперь, если в адресной строке ввести /catalog/all/2/, то откроется 2 страница. /catalog/all/3/ - откроется 3 страница, и тп.  



    4. Теперь нужно сделать, что бы я мог менять странице с помощью кнопок снизу сайта. 

        1. Открою catalog.html, и найду разметку пагинации (она там отмечена комментарием)

        2. Оставлю только один экземпляр страницы (там есть страница 1, 2, и 3, я удалю 2 и 3), и оберну его в шаблонный тег for с условием for page in goods.paginator.page_range .

            Я думаю, что если хоть чуть-чуть есть понимание английского, то ясно, что делает эта строка, но на всякий случай я поясню: для страницы в пагинаторе папки goods в количестве страниц 
            всего. 



        3. Вместо номера страницы 1 указываю в плейсхолдере мою переменную page

        4. В контроллере, в контексте завожу еще 1 пару ключ:значение, с ключом slug_url и значением category_slug

        5. В html разметке (catalog.html) в поле url пагинации записываю шаблонный тег url, и передаю туда путь до страницы: {% url = "catalog:index" slug_url page %}

            Теперь у меня работают кнопки на 1, 2, 3 страницу

        6. Теперь нужно активировать кнопки следущая и предыдущая страница:

            1. Для начала, открыв их теги, видно, что класс - disabled, то есть кнопка неактивна. Мне нужно, что бы если, например, есть предыдущая страница, то кнопка предыдущей страницы была активна,
            а если нет - неактивана .

            2. Прямо в теге записываю шаблонный тег if, с условием not goods.has_previous , и в этом условии - disabled. (то есть если нет предыдущей страницы, то кнопка неактивна.)

            3. Теперь, во вложенном теге а я добавлю параметр href, а в значении - опять же условие, но уже без not (если есть предыдущая страница): 
                
                href="{% if goods.has_previous %} {% endif %}"

            4. Если условие выполняется - то получить предыдущую страницу: указываю тег url и путь до страницы:

                href="{% if goods.has_previous %}{% url="catalog:index" slug_url goods.previous_page_number %}{% endif %}"

                То есть urls = catalog:index - путь /catalog/ , slug_url - /catalog/tovar/ , goods.previous_page_number - /catalog/tovar/1 

            5. Отлично, теперь копка предыдущей страницы работает!

            6. Аналогично делаю с кнопкой next, только не previous, а next, и тп. 

        7. Если на сайте перейти, например, на 3 страницу - то кнопка 3 страницы остается активной и никак не изменится - не понятно, на какой я странице. Это надо тоже поправить.

            1. Если в документации нажать на класс Paginator, то я увижу все его возможные атрибуты и методы, в числе которых has_next, has_previous, которые я уже использовал.
            Один из них - number - Текущая страница. 

            2. В цикле for, То теге ли с отображаемыми страницами, указываю в классе шаблонный тег if, с условием, что текущая страница это текущая страница в цикле. Класс будет не
            disabled, как в прошлых кнопках, а active - этот бутстраповский класс не отключает, а выделяет кнопку (напиши и посмотри как выглядит. Не понравится - поставь disabled). 

                {% if paginator.nuber == page %}active{% endif %}



        8. Но ведь страниц может быть не 4, как у меня а 50, ведь так? Более того: скорее всего их и будет больше. Не все же их отображать, представь как этот пагинатор 
        будет выглядеть? Исправляю:

            1. В документации найду: built in tag and filters

            2. Полистав, увижу фильтр add. Сейчас объясню, зачем он 

            3. Взгляни на конструкцию: 

                {% if page >= goods.number|add:-2 and page <= goods.number|add:2 %}

                    тег li, отрисовывющий пагинацию

                {% endif %}



            4. Дословно: если страница в моем цикле (page) больше, чем текущая страница, к которой добавить -2 и эта же страницаа меньше (или равно), чем текущая страница, к которой 
            добавить 2, то:

                но зачем add, если можно использовать goods.number-2 и goods.number + 2? 
                Нельзя. Это html, а не python, и тут такое не сработает. В итоге, добавив в мой цикл for эту конструкцию, я сделаю так, что бы в пагинаторе отображалась: 

                    Кнопка назад, 2 предыдущие страницы, текущая страница, 2 следущие страницы, кнопка вперед. 



            5. Можно обновить страницу. В данном случае, когда есть всего 4 страницы, пагинатор будет отображать либо 123 страницы, либо 234, либо 1234. 

            6. Добавлю немного про фильтры: вообще, они могут сильно упростить жизнь. Но помни: твоя задача как программиста - не знать все фильтры, команды, библиотеки алгоритмы методы
            конструкции и так далее, нет. Твоя задача - уметь искать информацию, обрабатывать и применять. Для меня все справки, что есть вообще на моем гитхабе - это некая база знаний,
            то, что используется часто и мне пригодится. Вся эта информация есть и в гугле, в документациях. Я не заучиваю все, что здесь написано, и всегда могу вернуться к нужной мне 
            справки и освежить, или просто найти нужную мне библиотеку, конструкцию, метод и тп. 

                Итак, фильтр. Если зайти на сайт, то видно, что описание карточки - не полное. В верстке это сделано при помощи бутстраповского css стиля text-truncate. Этого можно
                добиться и с помощью фильтров truncatechars, truncatewords. Эти фильтры указывают, сколько символов/слов оставить, а сколько добавить. Я удалю класс text-truncate, 
                и к product.description применю этот фильтр: обрежу до 35 символов.



    5. Исправление небольших недостатков:

        1. Нынешний url выглядит так:   http://127.0.0.1:8000/catalog/all/1/ . В принципе, все довольно понятно, но есть 1 но. В конце адреса цифра 1. Что это? Номер страницы? Может быть
        это id продукта? Или сортировка по рейтингу: показать только то, где 1 звезда? В реальном мире так не делается. Наверняка ты видел, что в сайте Url выглядит подобным образом: 

            https://domen.com/catalog/all/?q=nameproduct&page=3 



        2. Догадываешься, что я буду сейчас делать?

            На самом деле, подобные вещи page, клику на товар, вообще нажатие на любую кнопку на сайте принято делать с помощью ПАРАМЕТРОВ GET ЗАПРОСОВ, а не путем постоянного создания 
            сотен ненужных и неудобных url адрессов. 



ПАРАМЕТРЫ GET - ЗАПРОСОВ. 

    1. Пармаметры всегда начинаются с ?. Параметр q - сокращение от query, или запрос. То есть ?q=url это значит, что параметр запроса, или просто - запрос, это url. 

    2. Параметры подключаются очень просто: ничего не модифицируется, нужно лишь приспособить контроллер выхватывать эти запросы. 

    3. Подключаю к моему веб-приложению: 

        1. Для начала, я открою контроллер каталога и поставлю точку остановки где-то у контекста. Запускаю в дебаг-режиме.

        2. В браузере я в url адрес допишу параметр, например ?page=2&q=стул

        3. При нажатии enter, замигает значек приложения vscode (или твоего редактора кода). Открою, и увижу в run and debug 
        (бар слева, кнопка с "паузой"), variables, locals, что: 

            categorie_slug = 'all'
            current_page = <Page 1 of 4> 
            goods = <QuerySet [<Products: Чайный столик и три стула Количество - 10>, ...]
            page = 1 
            paginator = <django.core.paginator.Paginator object at 0x00000020C.....> 
            request = <WSGIRequest: GET '/catalog/all/1/?page=2&q=%D1%81%D1%82.....'>



        4. И если я разверну request, то увижу: GET = <QuerySet: {'page':['2'], 'q':['стул']}> . То есть, я могу получить эти 
        значения из request в контроллере. 

        5. Так как теперь страницу я буду передавать как параметр, я могу сразу удалить ее адрес из urlpatterns и удалить 
        его из аргументов контроллера.

        6. Теперь укажу в контроллере получение page. Объяснение: получить из словаря GET внутри request значение ключа 'page', 
        а если этого параметра нет - то page по умолчанию равен 1: 

            page = request.GET.get('page', 1)



        Здесь же, в переменной current_page указываю, что page это строго int. 
        
        7. А теперь... Мучался с шаблонным тегом url? Если да, то это печально, потому что на самом деле он не нужен. Удаляю в 
        разметке catalog.html все теги url для пагинации, и вместо них записываю параметр: 
            
            Для кнопки Предыдущей страницы: 
                href="?page={{goods.previous_page_number}}"



            Для кнопки с номером страницы: 
                href="?page={{page}}"



            Для кнопки Следущей страницы: 
                href="?page={{goods.next_page_number}}"



            P.S. НЕ УДАЛЯЙ IF, Я ПРОСТО ЗДЕСЬ ИХ НЕ ПИСАЛ ЧТО БЫ ВРЕМЯ НЕ ТРАТИТЬ

ФИЛЬТРАЦИЯ И СОРТИРОВКА ТОВАРА:

    1. На странице каталог есть кнопка фильтрации. Если нажать на нее - то я увижу параметры сортировки: по умолчанию, от дешевых, от дорогих и только товары по акции. C помощью этой формы клиент (браузер)
    будет отправлять в бэкенд GET-запрос с соответствующими параметрами 

    2. На странице catalog.html есть комментарий - форма фильтров, и меня сейчас интересует тег form.

        action -  url-запрос , по которому будет отправлен запрос

        methond - метод. Get - для получения обычных данных, post - для зашифрованных, на подобии логинов и паролей 

    3. Куда должна отправиться страница? в каталог. Тогда укажу маршрут в теге url: 

        action = "{% url "catalog:index" slug_url%}" 

    

    4. Метод - get

    5. В контроллере выхватываю значение из get:

        Для чекбокса "по акции": 

            on_sale = request.GET.get('on_sale', None)



        Для радиокнопок (сортировка по по возрастанию, убыванию и тп):

            order_by = request.GET.get('order_by', None)

    

    6. После этого я записываю условие: если on_sale, то фильтровать товары: только те, на которые есть скидка. Если order_by, то сортировать по order_by:

        if on_sale: 
            goods = goods.filter(discount__gt=0)

        if oreder_by:
            goods = goods.order_by(order_by)

    

    7. В catalog.html в теге form я закомментирую тег input с type="hidden", пока она не нужна. 

    8. Если посмотреть на значения радиокнопок (value), то это default, -price, price. -price и price - значит отсортироуется по убыванию и возрастанию соответственно. А вот default необходимо обработать в 
    контроллере: 

        if order_by я заменю на if order_by and order_by != "default"



    9. Делаю так, что бы выбранные фильтры сохранялись:

        1. У тега input (у радиокнопок) есть такой параметр - checked, который говорит что кнопка уже выбрана. Копирую его 

        2. В самом 1 input,(с class = "form-check-input" name="on_sale"), в конце теге пришу условие, если request.GET.on_sale == 'on', то выбрать кнопкку: 

            <input .... {% if request.GET.on_sale == 'on' %} checked {% endif %} 



        3. С кнопками сортировки делаю тоже самое: 

            Для сортровки по Уменьшению цены: 

                <input ... {% if request.GET.oreder_by == '-price' %} checked {% endif %}>

            По возрастанию: 

                <input ... {% if request.GET.oreder_by == 'price' %} checked {% endif %}>

            По умолчанию чуть труднее, тк он должен быть выбран сразу при входе на страницу: 

                <input ... {% if not request.GET.oreder_by  or request.GET.oreder_by == 'default' %} checked {% endif %}>



    10. Фильтрация работает, но если перейти на следущую страницу, она "ломается". Чтож, чиню: 

        Для начала, почему она не работает должным образом: при выборе странички на пагинации, url меняется с http://domen.com/catalog/all/?order_by=-price&on_sale=on на http://domen.com/catalog/all/?page=2. 
        Что бы это исправить, нужно как-то передать эти параметры на следующую страницу: 

            1. Открываю templatetags, goods_tags.py и создаю свой шаблонный тег:

                from django.utils.http import urlencode

                @register.simple_tag(takes_context=True):
                def change_params(context, **kwargs): 
                    query = context['request'].GET.dict()
                    query.update(kwargs)
                    return urlencode(query)



            2. Видно, что он отличается от прошлого, сейчас объясню все, что он делает: 

                1. Теперь в @register.simple_tag() есть аргумент takes_context, равный True . Она позволяет использовать все контекстные переменные, чем является request и все в словаре context. 
                2. query = context['request'].GET.dict() : из значения по ключу request получить данные, и сформировать из них словарь query. В нем содержатся старые парметры (order_by=-price)
                3. query.update(kwargs) : Расширяю его kwargs - новыми параметрами 
                4. return urlencode(query) : вернуть query в виде url адресса

            

            3. В catalog.html подгружаю тег - в начале файла пишу:

                {% load goods_tags %}


            
            4. Нахожу пагинацию, в ней цикл фор, и ссылку (тег a). Параметр href изменяю следущим образом: 

                Было: 
                    href="?page={{page}}"
                Стало: 
                    href="?{% change_params page=page%}"

                То есть ссылка теперь - первоначальная страница: http://domen.com/catalog/all + change_params page=page. То есть, допустим, до нажатия на пагинацию, ссылка была 
                http://domen.com/catalog/all/?order_by=-price. тогда ?order_by вырезается в query внутри change_params, к query добавляется страница - page=page (пусть будет 2), из него формируется фрагмент 
                url-адресса, и уже этот фрагмент добавляется к http://domen.com/catalog/all. Тогда итоговый маршрут: http://domen.com/catalog/all/?order_by=-price&page=2



            5. Это было для на кнопки с номером страницы. Теперь для следущей, как для предудущей думаю поймешь: 

                href="?{% change_params page=next_page_number%}"



ПОИСК: 

    1. Отдельно делаю url маршрут для поиска, что бы он корректно отображался.: 

        В urls.py (goods) добавляю путь: path('search/', veiws.catalog, name='search')  . ОН ДОЛЖЕН БЫТЬ ПЕРВЫМ В КОЛЛЕКЦИИ, ОБЯЗАТЕЛЬНО !!!
        


    2. В base.html есть отдельная форма поиска, ее параметр role = search (у меня это 71 строка). Добавляю параметры:
        
        action = "{% url "catalog:search" %}"
        method = "get"


        
    3. В теге input внутри формы добавляю параметр name="q"

    4. Что бы сохранялись фильтры, введенные пользователем перед поиском, нужно внести пару изменений в catalog.html: 

        1. Раскомментировать тег input для поиска (в фильтрации), который я закомментировал ранее 
        
        2. Обернуть его в условие, если request.GET.q  

        3. value этого тега Input должно быть {{ request.GET.q }}

        4. В теге form выше, нужно тоже сделать проверку: 

            <form action="{% if request.GET.q %}{% url "catalog:search" %}{% else %}{% url "catalog:index" slug_url %}{% endif %}"

        5. Я напомню, что делает параметр action: куда будет сделан запрос. То есть, если что-то ввели в поиск, то меня интерисует страница catalog:search. А если нет, и поиск пустой - 
        меня интерисует catalog:index slug_url 

    

    5. А теперь нужно доработать контроллер, реализовать алгоритм поиска:

        1. Получаю запрос: 

            query = request.GET.get('q', None)


        2. Т.к выборка из бд с помощью сложных алгоритмов фильтрации может занимать очень много места, в контроллере пишется только логика самого контроллера. Создаю в goods файл utils.py 

        3. В utils.py создаю функцию q_search, в качестве аргумента передаю query, и делаю заглушку 

        4. Импортирую эту функцию в контроллер 

        5. Где условие, если category_slug == all, я добавляю:

            elif query: 
                goods = q_search(query)


        6. Так же необходимо сделать category_slug необязательным аргументом, и по умолчанию он равен None (потому что если я использую поиск, то в category_slug ничего не попадет, это
        вызовет ошибку.)

        7. Пишу ф-ю q_search: удаляю заглушку и: 

            1. Во-первых, реализую поиск по id: 
                
                if query.isdigit() and len(query) <= 5: 
                    return Products.objects.filter(id = int(query))

                Если query - целочисленное значение и его длина меньше/равна 5, то вернуть из таблици Products только тот продукт, у которого id = int(query)
                Почему я использую filter, а не get? Потому что функция должна вернуть QuerySet, состоящий из в данном случае 1 продукта. А get вернет сам продукт, но не QuerySet.

                Теперь, можно вбить любой id, и найдется продукт с этим id. Можно в поиске не вбивать 00005, а 005 или 5, тк isdigit все равно урежет его до 5



            2. Поиск по ключевым словам из описания товара: 

                1. Из django.db.models импортирую Q 

                2. Посмотрю в терминале, как вообще будет выглядеть то, что я сейчас буду делать: 

                    1. в терминале запускаю  debugsqlshell: python manage.py debugsqlshell

                    2. Импортирую все, что мне пригодится: 

                        from django.dm.models import Q 
                        from goods.models import Products 
                        from goods.utils import q_search 

                    3. Помнишь, как я фильтровал, что бы в описании было или диван, или цена меньше 50? 

                        Products.objects.filter(price__lt=50) | Products.objects.filter(description__contains='диван') 

                        Так вот, с помощью Q можно это сильно упростить: 

                        Products.objects.filter(Q(description__contains="диван") | Q(price__lt=50))

                    4. Запишу в переменную x QuerySet из продуктов, либо включающих в имя "диван", либо в описание: 

                        x = Products.objects.filter(Q(description__contains="диван") | Q(name__contains="Диван"))

                        При выводе получу только 2 товара - угловой диван для гостинной (диван в описании) и Диван обыкновенный (Диван в имени)

                    5. Проверю, что у 1 товара действительно есть диван в описании: 

                        x[0].description


                3. Посмотрел, теперь сделаю это в функции: 

                    1. Создаю список keywords, который является генератором: 

                        keywords = [word for word in query.split() in len(word) > 2]

                        То есть, keywords состоит из слов, которые взяты из query, привращенного в список по пробелам (если query = "Стол и стул", то query.split = ['Стол', 'и', 'стул']), и 
                        эти слова должны иметь польше 2-х букв (для исключения предлогов)
                   
                   
                   
                    2. создаю переменную q_objects, равная пустому Q. В ней будут лежать параметры фильтрации (q_objects = Q(Q(description__icontains="word1"), Q(description__icontains="word1")))

                        q_objects = Q()
                    


                    3. Добавляю цикл для добавления параметров фильтрации в q_objects 

                        for token in keywords: 
                            q_objects |= Q(description__icontains=token)        

                            |= это как += . То есть в q_objects добавить параметр фильтрации Q(description__icontains="word1")



                    4. ф-я возвращает Products.objects.filter(q_objects), то есть возвращает QuerySet из продуктов, отфильтрованным по параметрам фильтрации q_objects.
            
                Итак, запустил сервер, проверил поиск - работает!

            3. Теперь добавляю возможность поиска не только по описанию, но и по названию: 

                1. На самом деле, вообще ничего трудного. Просто в цикл for добавляю еще один q_objects |= Q(name__icontains=token) (да, просто аргумент теперь - имя а не описание)



POSTGRESQL 

    Джанго можно расширить разными пакетами, например для полнотекстового поиска. PostgreSql - субд, которая позволит сделать такой поиск. Ее можно использовать и при локальной разработке 
    на тестовом сервере (как сейчас, например), так и на самом сервере при деплойте. Сейчас я заменю не очень удобную sqlite на PostgreSql. 

    1. Ее необходимо скачать на пк с оффициального сайта: https://www.postgresql.org/

    2. Перед установкой зайду в документацию джанго и уввижу: что Django поддерживает любую PostgreWQL выше 12 версии. Так же там написано, что необходимо скачать psycopg . 
        Ссылка на данный текст: https://docs.djangoproject.com/en/5.0/ref/databases/#postgresql-notes (отзюда же по ссылке скачиваю psycopg)

    3. Подготовка к переходу на PostgreSql: 
    
        1. Удаляю все fixtures

        2. Делаю dumpdata:

            python -Xutf8 ./manage.py dumpdata goods.Categories > fixtures/goods/categories.json

            python -Xutf8 ./manage.py dumpdata goods.Products > fixtures/goods/products.json    

        3. Удаляю db.sqlite3

    4. Переход на PostgreSql:

        1. Открываю файл settings.py > databases, и меняю: 
            
            1. значение ключа 'ENGINE' теперь: 'django.db.backends.postgresql'
            2. значение ключа 'NAME' теперь: 'postgres'
            3. Создать пару ключ-значение 'USER':'postgres'
            4. Создать пару ключ-значение 'PASSWORD':'YourPassword' (тот, который ты вводил при установки postgresql)
            5. Создать пару ключ-значение 'HOST':'localhost'
            6. Создать пару ключ-значение 'PORT':'5432' (или тот порт, что ты поставил при установке)



        2. Запущу pgAdmin4 (скачался вместе с postgre)

        3. Нажимаю Servers 

        4. Ввожу пароль

        5. По пути Servers>Databases>postgres>Schemas>public>Tables будут лежат мои таблицы (пока еще их нет) 

        6. Хотя нет, я обманул, не будут. Как правило с самой стандартоной 'postgres' не работают, и создают для себя новую. Это я и сделаю:

            1. Есть три способа создать user: 

                Через pgAdmin4:

                    1. ПКМ по Login/Group Roles > Create > Login/Group Role

                    2. Даю имя (я даю Home, как у автора). Comments пропускаю 

                    3. Во вкладке definition: password - пусть будет home 

                    4. Privileges - все.

                    5. Открою вкладку SQL. Там будет запрос. Его можно ввести в строку для создания таблицы через консоль

                    6. Сохраняю
                Через консоль: 

                    1. Через sql shell (найти можно через поиск windows/в папке postgresql)

                        1. Server [localhost] - нажимаю Enter 
                        2. Database [postgres] - Enter 
                        3. Port [5432] - Enter / выбранный вами порт, Enter 
                        4. Username [postgres] - Enter 
                        5. Пароль - ввожу пароль 
                        6. ввоожу запрос.



                    2. Через cmd:  

                        1. Что бы получилось, нужно зайти в папку Postgresql > версия > bin и скопировать путь до psql.exe. Этот путь добавить в path

                        2. Либо можно запустить без добавления в path, вставив в cmd путь до файла -U postgres (или ваше имя таблицы, пользователя, хз как это назвать)

                            "C:\Program Files\PostgreSQL\17\bin\psql.exe" -U postgres (Пример как у меня)
                        
                        3. Ввожу пароль

                        4. Ввожу запрос



            2. Теперь создаю database:
             
                1. Пкм по databases > Create > database

                2. Имя - home. Owner - home 
                3. Defenition - Encoding - UTF8 
                4. SQL - опять же, можно ввести в терминал

        

        7. И вот уже по пути Servers > PostgreSQL > Database > home > Schemas > public > tablses будут лежать мои таблицы. 

        8. В settings.py меняю значение ключей 'NAME', 'USER', 'PASSWORD' на только что созданные (у меня это home, home, home)

        9. Теперь делаю миграции и применяю их: 

            python manage.py makemigrations 
            python manage.py migrate



ПОЛНОТЕКСТОВЫЙ ПОИСК С ВЫДЕЛЕНИЕМ РЕЗУЛЬТАТОВ

    1. Для подключения полнотекстового поиска в django с помощью PostgreSQL, нужно подключить приложение 'django.contrlib.postgres'

        settings.py > INSTALLED_APPS = [ ... , 'django.contrib.postgres']


    
    2. В файле utils.py я закомментировал поиск, который недавно написал, оставив условие. Сейчас я его перепишу: 

        1. return Products.objects.filter(description__search=query)   

        И все, больше не нужно. Но в чем отличие от предыдущего поиска? В том, что сейчас поиск работает по принципу схожести. 
        То есть, например, раньше, вбив в поиск ст, мне выдавались все продукты, у которых в слове есть 'ст'. Столик, стол, стул, 
        стук, стандартизация, просто - все эти слова могли бы стать результатом поиска. Сейчас же, поиск идет по так называемой 
        схожести, проценту совпадения символов. Вбив слово стол, я не получу в результате столяр, столешница, апостол и тд. Я получу: 
        стол, столы, стола. Потому что они максимально схожи

        О том, как осуществялть полнотекстовый поиск, можно почитать в документации по запросу "Full text search". 


    
    3. SearchVector. Этот способ позволяет сочитать полнотекстовый поиск как по описанию, так и по имени: 

        1. Импортирую SearchVector:

            from django.contrib.postgres.search import SearchVector

        2. Удаляю в utils.py return без условия, заменяя: 

            return Products.objects.annotate(search=SearchVector("name", "description")).filter(search=query)

                Анотация в джанго - метод, применяющийся к QuerySet, возвращающий те же объекты класса модели, но с доп атрибутами. В данном случае - эти объекты должны содержать в 
                name или description мой запрос (query)

                Дословно: применить к объектам в products поиск по 2-ум полям - по имени и описании, фильтруя по запросу (тексту, введенному в поиск на странице), и вернуть подошедшие объекты

            В SearchVector я передаю поля из моей модели, по которым осуществляется поиск - name и description

    

    4. Сортировка по релевантности:

        1. В том же utils.py, после условия и первого return: 

            vector = SearchVector("name", "description")
            query = SearchQuery(query)
            
            return Products.objects.annotate(rank=SearchRank(vector, query).order_by("-rank"))
        
        Не забудь импортировать SearchQuery и SearchRank

        2. Теперь выдаются товары, не соответствующие запросу: 

            1. Через debugsqlshell посмотрю, что вообще возвращает ф-я: 

                python manage.py debugsqlshell 

                from goods.utils import q_search

                x = q_search('стул')

                fro i in x:
                    print(i.rank)
            

            
            2. Вижу, что возвращаются вообще все товары, но у неподходящих rank = 0. Значит, отфильтрую так, что бы rank был > 0:

                return Products.objects.annotate(rank=SearchRank(vector, query)).filter(rank__gt=0).order_by("-rank")   



    5. SearchHeadLine: выделение текста, вбитого в поиск, при помощи тега span:

        1. Помещу return в переменную result: 

            result = Products.objects.annotate(rank=SearchRank(vector, query)).filter(rank__gt=0).order_by("-rank")   
 
        2.  Допишу: 

            result = result.annotate(headline=SearchHeadline("name", query, start_sel = '<span style="background-color: yellow;">', stop_sel="</span>",))

                Произвожу еще раз анотацию result, headline = поле, в котором по названию (name) ищу слова из запроса (query), и 
                применяю к нему тег span со стилем ... (start_sel), а так же не забываю закрыть его (stop_sel)

                Анотация в джанго - метод, применяющийся к QuerySet, возвращающий те же объекты класса модели, но с доп атрибутами. В данном случае - окрашивание слов из поиска

            result = result.annotate(bodyline=SearchHeadline("description", query, start_sel='<span style="background-color: yellow;">', stopstop_sel="</span>",))

                Произвожу аннотацию того же result (QuerySet), но уже к description из запроса query, и применяю к нему стиль при помощи span. 



        Что я только что написал? Я добавил все результаты поиска из бд в переменную result, а затем добавил выделение желтым отдельно для совпадения в имени, и отдельно для описания. 
        
       
       
        3. Сейчас, после анотирования и появления новых атрибутов у объектов, для отображения на странице необходимо поработать в шаблоне catalog.html:

            1. Нахожу плейсхолдер product.name , и перед ним добавляю условие: если есть headline (то есть имя - результат поиска,) то {{product.headline}}, иначе {{product.name}}

                <p... >{% if product.headline %}{{ product.headline }}{% else %}{{ product.name }}{% endif %}</p>
                
            2. То же делаю и для product.description:

                <p... >{% if product.bodyline %}{{ product.bodyline|truncatechars:35 }}{% else %}{{ product.description|truncatechars:35 }}{% endif %}</p>
            

       
       
        4. Проверяю: результат не тот, что я ожидал: вместо выделения желтым весь текст стал некрасивой ссылкой, а надпись стол не то что не выделилась, а превратилась в 
        <span style ...>стол</span>. Это потому, что весь html из бд экранируется и не обрабатывается django. Что бы это сработало, нужно указать, что я хочу отобразить 
        эту разметку:

            1. Перед {% if product.headline %} добавляю тег {% autoescape off %}, а после {% endif %} - {% endautoescape %}. То же самое делаю и для описания.

            2. При проверки работы я увижу, что описание съело. Это произошло из-за того, что truncatechars считает еще и html разметку. Просто увеличу truncatechars До 100: (только там, 
            где product.bodyline )

            Теперь все так, как и должно быть 


    6. Еще добавлю проверку: если был выполнен поиск, то должен появиться подзаголовок "Результаты поиска по запросу ...". При этом, если ничего не найдено, сообщить об этом.    
    
        {% if request.GET.q %}
        <h3 class="mt-4"> Результаты поиска по запросу "{{ request.GET.q }}": </h3>
        {% if not goods %}
            <h2 class="mt-4"> По запросу ничего не найдено</h2>
        {% endif %}
        {% endif %}

    7. Из index.html скопирую из блока css стиль, и вставлю прямо после {% if not goods %}. Это прилепит Copyright .. Home Python Hub Studio 2023 вниз страницы, если нет результатов.
    А для пагинации: 
        Прямо под комментарием "Пагинация"

            {% if goods %}

        И в конце пагинации:

            {% endif %}

            

    Все, поиск закончен окончательно. Делаю коммит.



МИКРОДОРАБОТКИ:

    1. Плохо, что base.html лежит в приложении main, тк он относится ко всем приложениям:

        1. В settings.py нахожу список TEEMPLATES, и значением 'DIRS' указываю:

            'Dirs': [BASE_DIR/'templates']

        2. В корне создаю папку templates, и в нее перекидываю base.html. 

        3. Нужно сделать легкий рефактор: захожу в поиск (в vs code слева), и в 1 поле вставляю {% extends "main/base.html" %}, во второе - {% extends "base.html" %}.
        Заменяю 

        4. Проверяю работоспособность.



ПРИЛОЖЕНИЕ USERS: 

    1. Создаю users:

        python manage.py startapp users

    2. Регистрирую приложение: 

        В settings.py указываю в список INSTALLED_APPS 'users', 

    3. Создаю в users папку templates, вложенную подпапку users для шаблонов html.

    4. Создаю в users файл urls.py. 

    5. В корневом urls.py создаю путь к urls.py users

        path('user/', include('users.urls', namespace='user'))

    6. Что бы не писать с нуля, скопирую urls.py приложения goods, вставлю в urls.py приложения users, и заменю значения на подходящие. Пути будет 4, тк будет
    четыре страницы: вход, регистрация, профиль и выход. Итог:

        from django.urls import path
        from users import views

        app_name = 'users'

        urlpatterns = [
            path('login/', views.login, name = 'login'),
            path('registration/', views.registration, name = 'registration'),
            path('profile/', views.profile, name='profile')
            path('logout/', views.logout, name='logout')
        ]
    

    
    7. Теперь напишу контроллеры: впринципе, ничего сложного:

        Открываю views.py приложения users и пишу (ты должен помнить, что это значит):

            def login(request):
                context = {
                    'title':'Home - вход'
                }
                return render(request, 'users/login.html', context)


            def registration(request):
                context = {
                    'title':'Home - регистрация'
                }
                return render(request, 'users/registration.html', context)


            def profile(request):
                context = {
                    'title':'Home - профиль'
                }
                return render(request, 'users/profiel.html', context)


            def logout(request):
                ...



    8. Делаю шаблоны: в templates/users создаю 3 шаблона: login.html, registration.html, profile.html (выход будет внутри profile.html, Поэтому не нужен logount.html)

    9. Открою одноименные файлы из верстки, и смотрю: есть ли футер, есть ли стиль для него (спойлер: их нет, мне лучше), и копирую уникальные блоки (контент)

        1. В файле login.html (из верстки) копирую весь контент на страницу (обозначено комментарием)

        2. Вставляю в файл login.html приложения users, в {% block content %}{% endblock %}. Предворительно не забываю расширить файл от base.html и 
        подключить статику: {% extends "base.html" %}, {% load static %}

        3. То же самое делаю и с registration.html, profile.html

    10. Теперь, для удобства, в base.html добавлю ссылки (в навигационную панель) для входа и регистрации:

        51 60 66 строки, в href вставляю {% url "users:namespace" %} (namespace надеюсь сам вставишь, но на всякий: login, profile, logout)

        А вот регистрация находится в файле login.html (примерно 22 строка (в зависимости от того, как ты вставил, строка может немного отличаться.))

    11. Подключу статику (напомню: для подключения статики - href={% url "путь до статик файла" %}). Пути до статик-файлов там уже указаны, просто скопирую. 
        
        В login.html:
            
            35 39 43 строка 

        В profile.html:

            22 строка

            Корзину пока нужно удалить (Закоментированно как разметка корзины)

    12. Запущусь и проверю работоспособность.

    13. Когда я подключал ссылки для навигационной панели, я указывал маршрут users:login (как пример). Но в корневом urls.py namespace для приложения users 
    это namespace='user', и в теории должна была случиться ошибка, но ее не случилось. Почему? Да потому, что в urls.py приложения users у меня есть такая строк:
    app_nmae='users' . По этому и сработало. То есть в маршрутах можно указать как namespace, так и app_name. Заменю users на user в маршрутах (на каких строках)
    они находятся есть выше.


        Делаю коммит.